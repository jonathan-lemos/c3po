use crate::parser::parse::failedparse::FailedParse;
use crate::parser::parse::successfulparse::SuccessfulParse;
use super::super::cursor::cursor::Cursor;
use super::super::parse::parse::Parse;

/// The output type of `Parser::parse`.
pub struct ParserOutput<'a, TOutput> {
    pub beginning: Option<Cursor<'a>>,
    pub kind: String,
    pub parse: Parse<'a, TOutput>,
}

impl<'a, TOutput> ParserOutput<'a, TOutput> {
    /// Creates a new ParserOutput
    /// 
    /// # Arguments
    /// * `parse`     - A parse generated by a parsing function. See `Parser::func` for details.
    /// * `beginning` - A Cursor pointing to the first token of the parse.
    /// * `kind`      - What kind of value this parse has (on success).
    pub fn new<S: Into<String>>(parse: Parse<'a, TOutput>, beginning: Option<Cursor<'a>>, kind: S) -> Self {
        ParserOutput {
            beginning,
            kind: kind.into(),
            parse
        }
    }

    /// If this contains a successful parse, return a new ParserOutput as a function of the old ParserOutput, otherwise return the existing failure.
    /// 
    /// For Haskell folk, this binds on the success case.
    /// 
    /// # Arguments
    /// * `if_successful` - If the ParserOutput contains a successful parse, run this function.
    pub fn and_then<F: FnOnce(Self) -> Self>(self, if_successful: F) -> Self {
        if self.parse.is_success() {
            if_successful(self)
        } else {
            self
        }
    }

    /// Unwraps a successful parse if this contains one. Otherwise panics with the given message.
    pub fn expect<S: AsRef<str>>(self, message_if_not_success: S) -> SuccessfulParse<'a, TOutput> {
        self.parse.expect(message_if_not_success)
    }

    /// Unwraps a failed parse if this contains one. Otherwise panics with the given message.
    pub fn expect_failure<S: AsRef<str>>(self, message_if_not_failure: S) -> FailedParse<'a> {
        self.parse.expect_failure(message_if_not_failure)
    }

    /// `true` if the Parse failed, `false` if not.
    pub fn is_failure(&self) -> bool {
        self.parse.is_failure()
    }

    /// `true` if the Parse succeeded, `false` if not.
    pub fn is_success(&self) -> bool {
        self.parse.is_success()
    }

    /// If the contained parse is a success, transforms the old value into a new value, otherwise keeps the original failure.
    /// 
    /// # Arguments
    /// * `mapper` - A function that transforms the old value into a new one.
    pub fn map<TNewOutput, F: FnOnce(TOutput) -> TNewOutput>(self, mapper: F) -> ParserOutput<'a, TNewOutput> {
        ParserOutput {
            beginning: self.beginning,
            kind: self.kind,
            parse: self.parse.map(mapper)
        }
    }

    /// If the contained parse is a failure, transforms the old reason into a new reason, otherwise keeps the original success.
    /// 
    /// # Arguments
    /// * `mapper` - A function that transforms the old reason into a new one.
    pub fn map_reason<S: Into<String>, F: FnOnce(String) -> S>(self, mapper: F) -> Self {
        ParserOutput {
            beginning: self.beginning,
            kind: self.kind,
            parse: self.parse.map_reason(mapper)
        }
    }

    /// If this contains a failed parse, return a new ParserOutput as a function of the old ParserOutput, otherwise return the existing success.
    /// 
    /// For Haskell folk, this binds on the failed case.
    /// 
    /// # Arguments
    /// * `if_failed` - If the ParserOutput contains a failed parse, run this function.
    pub fn or_else<F: FnOnce(Self) -> Self>(self, if_failed: F) -> Self {
        if self.parse.is_failure() {
            if_failed(self)
        } else {
            self
        }
    }

    /// Unwraps a SuccessfulParse if the parse succeeded. Panics if it failed.
    pub fn unwrap(self) -> SuccessfulParse<'a, TOutput> {
        self.expect("unwrap() called on a failed parse.")
    }

    /// Unwraps a FailedParse if the parse failed. Panics if it succeeded.
    pub fn unwrap_failure(self) -> FailedParse<'a> {
        self.expect_failure("unwrap_err() called on a successful parse.S")
    }
}
